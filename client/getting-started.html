<template name="getting-started">
{{#markdown}}

#Getting Started

This guide will get you started started with Velocity in a few minutes. Here are a few ways to begin:

## I want to add testing to my app
If you are relatively new to testing or just want to keep things simple, we recommend beginning with an integration testing framework. **Integration testing** gives you access to the full application environment in a mirror process. The mirror can run without affecting your main live app, so it will not interfere with manual tests and anything else you need to do with your app while you develop. These tests are also fast enough to give you real-time feedback. Velocity currently has two packages that implement integration testing, and you can choose based on features or the syntax that you prefer.

### Adding Mocha
https://atmospherejs.com/mike/mocha

### Adding Jasmine
https://atmospherejs.com/?q=jasmine

## I want to see an example
You can see a working example of the Meteor Leaderboard example app with working tests by downloading the [velocity demo](https://github.com/meteor-velocity/velocity-example).

    # clone the velocity-example repo and run meteor
    $ git clone https://github.com/xolvio/velocity-example.git
    $ cd velocity-example
    $ meteor

## What other tests can I run?
While we advocate that most developers start with integration testing, there are other types of tests that may be more suitable for your situation.

**Unit tests** run without the full environment, isolating code units such as functions and objects for testing. This requires you to mock any outside objects needed by the unit currently being tested. Velocity provides most of your  mocking automatically, but you will still need to do some of your own to make the tests work. In return for this investment, you get much faster tests; this is by far the fastest form of testing (order of magnitude?). It also encourages you to write modular, decoupled code. The [Jasmine framework](https://atmospherejs.com/?q=jasmine) currently supports unit testing.

**End-to-end tests** simulate manual testing by performing clicks, data entry, and other tasks that a user would perform and then verifying that the interface of the app responds correctly. They have the advantage of confirming that the entire process is working as a whole, whereas other tests may miss problems that occur during the interactions between components. End-to-end tests are also very intuitive to write. However, these tests can be more brittle (one ID change in a template may break multiple tests) and also may not tell you *where* an error occurred. They also tend to run slowly enough that it is impractical to run them every time you save your code. Selenium is the tool most used for end-to-end testing, and you can use that with the [Nightwatch framework](https://github.com/meteor-velocity/nightwatch-framework)

There are other kinds of testing, such as performance tests, smoke tests, and other metrics such as code coverage. We will be adding resources that help you learn about your options as the project develops. Pull requests ([here](https://github.com/meteor-velocity/website)) are encouraged!






## Resources

### Currently available testing frameworks 
[Submit a pull request here](https://github.com/meteor-velocity/website) to add your framework to this website.



{{/markdown}}
</template>
